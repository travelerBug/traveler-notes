

## OSI七层网络模型

- **物理层**
- **数据链路层**
- **网络层**
- **传输层**
- **会话层**
- **表示层**
- **应用层**





## Tcp/Ip 协议



##  3 .Socket通信的基本步骤

### 3.1 创建Socket

> 使用net包中的Dial或Listen函数创建Socket，Dial函数用于创建客户端Socket，Listen函数用于创建服务器Socket。绑定ip和端口号。

`端口号`是一个16位的无符号整数，范围从0到65535。其中，0到1023是系统保留端口，一般应用程序不使用。1024到49151是用户注册端口，可以用于一些普通应用程序。49152到65535是动态端口，一般不需要手动配置，由系统自动分配。

### 3.2 建立连接

>  在客户端中，使用Dial函数连接服务器，服务器中使用Accept函数接受客户端连接。

### 3.3 发送数据

> 使用Socket的Write方法向对方发送数据。

### 3.4 接收数据

> 使用Socket的Read方法从对方接收数据。

### 3.5 关闭连接

> 使用Socket的Close方法关闭连接。在服务器中，需要在处理完客户端请求后关闭连接，而在客户端中，需要在发送完数据后关闭连接。



## 4.拓展

#### 4.1 为什么没有设置半连接池的大小？

在Go语言中，没有设置最大连接数的原因是因为Go语言的设计者们认为，如果在代码中设置了最大连接数，那么就会出现两种情况：一种是设置的连接数太小，导致服务器无法处理所有的客户端请求；另一种是设置的连接数太大，导致服务器资源浪费。因此，Go语言的设计者们决定不在代码中设置最大连接数，而是让操作系统自己来处理连接数的问题。在Linux系统中，操作系统会根据服务器的硬件配置和负载情况来自动调整连接数，从而保证服务器的性能和稳定性。因此，在Go语言中，我们不需要手动设置最大连接数，只需要编写好服务器程序，让操作系统来自动管理连接数即可。

#### 4.2 发送长度为0的字节数组发生阻塞？

在TCP协议中，发送长度为0的字节数组不会发生阻塞，因为发送长度为0的字节数组相当于发送了一个空消息，不会占用网络带宽和服务器资源。如果发送长度为0的字节数组发生了阻塞，可能是因为网络连接出现了问题，或者是服务器的资源已经耗尽，无法处理更多的请求。如果您遇到了这种情况，可以尝试检查网络连接和服务器资源，或者是调整代码中的发送逻辑，避免发送长度为0的字节数组。

#### 4.3 Accept函数是否在等待半连接池中是否有请求？

这里的conn, err := listener.Accept()是在等待半连接池中是否有请求。在TCP协议中，当客户端向服务器发送SYN包时，服务器会向客户端发送SYN+ACK包，此时连接处于半连接状态，即服务器已经接受了客户端的请求，但是还没有完全建立连接。在这个状态下，服务器会将客户端的请求放入半连接池中，等待客户端发送ACK包，完成连接的建立。而conn, err := listener.Accept()就是在等待半连接池中是否有请求，如果有请求，就会返回一个连接对象conn，否则会一直阻塞等待。

























